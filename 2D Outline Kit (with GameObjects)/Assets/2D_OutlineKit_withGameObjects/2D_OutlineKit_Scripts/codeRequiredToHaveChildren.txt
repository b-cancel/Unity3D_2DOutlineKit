//----------only in class

[Header("Family Relationships")]
public GameObject parentGOWithScript;
GameObject prevParentGOWithScript;

public List<GameObject> children;

//----------inside of every property that we want our children to copy

for (int i = 0; i < children.Count; i++)
{
    if (children[i] != null)
    {
        if (children[i].GetComponent<someScript>() != null)
            children[i].GetComponent<someScript>().SomeVar = SomeVar;
    }
    else
    {
        children.RemoveAt(i);
        i--;
    }
}

//----------heavily modified size

float size_O; //NOTE: this size refers to the world space thickness of the outline
//NOTE: used in update function... doesnt have to do anyting special for get and set...
public float Size_O
{
    get { return size_O; }
    set
    {
        float oldSize = size_O;

        value = (value >= .1f) ? value : .1f; //since our childrens' size depends on our porportion with them we avoid our size being 0
        size_O = value;//update local value

        if (forceRetainPorpWithChildren)
        {
            float smallestPossibleSize = size_O;

            //go through all of our children... make sure that we can make our size as small as we want it to be
            for (int i = 0; i < children.Count; i++)
            {
                if (children[i] != null)
                {
                    float currOurs = oldSize;
                    float newOurs = smallestPossibleSize;

                    if (children[i].GetComponent<convexOutlineV3>() != null)
                    {
                        float currTheirs = children[i].GetComponent<convexOutlineV3>().Size_O;
                        float newTheirs = (currTheirs / currOurs) * newOurs;

                        if (newTheirs < .1f) //we have to increase our size to keep our porportion with them
                        {
                            newTheirs = .1f;
                            newOurs = currOurs * (newTheirs / currTheirs);

                            if (newOurs > smallestPossibleSize)
                                smallestPossibleSize = newOurs;
                        }
                    }

                    if (children[i].GetComponent<concaveOutlineV3>() != null)
                    {
                        float currTheirs = children[i].GetComponent<concaveOutlineV3>().Size_O;
                        float newTheirs = (currTheirs / currOurs) * newOurs;

                        if (newTheirs < .1f) //we have to increase our size to keep our porportion with them
                        {
                            newTheirs = .1f;
                            newOurs = currOurs * (newTheirs / currTheirs);

                            if (newOurs > smallestPossibleSize)
                                smallestPossibleSize = newOurs;
                        }
                    }
                }
                else
                {
                    children.RemoveAt(i);
                    i--;
                }
            }

            size_O = smallestPossibleSize;
        }

        //update the outline of your children
        for (int i = 0; i < children.Count; i++)
        {
            if (children[i] != null)
            {
                float currOurs = oldSize;
                float newOurs = size_O;

                if (children[i].GetComponent<convexOutlineV3>() != null) //child has convex outline [DIFFERENT]
                {
                    float currTheirs = children[i].GetComponent<convexOutlineV3>().Size_O;
                    float newTheirs = (currTheirs / currOurs) * newOurs;

                    children[i].GetComponent<convexOutlineV3>().Size_O = newTheirs;
                }

                if (children[i].GetComponent<concaveOutlineV3>() != null) //child has concave outline [SAME]
                {
                    float currTheirs = children[i].GetComponent<concaveOutlineV3>().Size_O;
                    float newTheirs = (currTheirs / currOurs) * newOurs;

                    children[i].GetComponent<concaveOutlineV3>().Size_O = newTheirs;
                }
            }
            else
            {
                children.RemoveAt(i);
                i--;
            }
        }

        UpdatepositionsOfEdges();
    }
}

//-----

bool forceRetainPorpWithChildren;
public bool ForceRetainPorpWithChildren
{
    get { return forceRetainPorpWithChildren; }
    set
    {
        forceRetainPorpWithChildren = value;
        Size_O = size_O;
    }
}

//---------------in the awake function

//---Children
children = new List<GameObject>();
if (parentGOWithScript != null && children.Contains(parentGOWithScript) == false) //if someone wants to be our parent... and they are not already our child...
{
    if (parentGOWithScript.GetComponent<concaveOutlineV3>() != null)
    {
        if (parentGOWithScript.GetComponent<concaveOutlineV3>().children.Contains(this.gameObject) == false)
            parentGOWithScript.GetComponent<concaveOutlineV3>().children.Add(this.gameObject);
    }
    else if (parentGOWithScript.GetComponent<convexOutlineV3>() != null)
    {
        if (parentGOWithScript.GetComponent<convexOutlineV3>().children.Contains(this.gameObject) == false)
            parentGOWithScript.GetComponent<convexOutlineV3>().children.Add(this.gameObject);
    }
}
else
    parentGOWithScript = null;

forceRetainPorpWithChildren = true;

//---------------in the update function

//---Clear Children we no longer need

for (int i = 0; i < children.Count; i++)
{
    if (children[i] == null)
    {
        children.RemoveAt(i);
        i--;
    }
}

//---parent child relationship

if (parentGOWithScript != prevParentGOWithScript) //if we change parents
{
    //TODO... reconfigure to work with any of our 6 scripts
    if (prevParentGOWithScript != null) //If we had a parent... break all ties with them
    {
        if (parentGOWithScript.GetComponent<convexOutlineV3>() != null)
        {
            if (prevParentGOWithScript.GetComponent<convexOutlineV3>().children.Contains(this.gameObject) == true)
                prevParentGOWithScript.GetComponent<convexOutlineV3>().children.Remove(this.gameObject);
        }
        else if (parentGOWithScript.GetComponent<concaveOutlineV3>() != null)
        {
            if (prevParentGOWithScript.GetComponent<concaveOutlineV3>().children.Contains(this.gameObject) == true)
                prevParentGOWithScript.GetComponent<concaveOutlineV3>().children.Remove(this.gameObject);
        }
    }

    //make ties with new parent
    if (parentGOWithScript != null && children.Contains(parentGOWithScript) == false) //if someone wants to be our parent... and they are not already our child...
    {
        if (parentGOWithScript.GetComponent<concaveOutlineV3>() != null)
        {
            if (parentGOWithScript.GetComponent<concaveOutlineV3>().children.Contains(this.gameObject) == false)
            {
                parentGOWithScript.GetComponent<concaveOutlineV3>().children.Add(this.gameObject);
                parentGOWithScript.GetComponent<concaveOutlineV3>().updateUniversalVars();
            }

        }
        else if (parentGOWithScript.GetComponent<convexOutlineV3>() != null)
        {
            if (parentGOWithScript.GetComponent<convexOutlineV3>().children.Contains(this.gameObject) == false)
            {
                parentGOWithScript.GetComponent<convexOutlineV3>().children.Add(this.gameObject);
                parentGOWithScript.GetComponent<convexOutlineV3>().updateUniversalVars();
            }

        }
    }
    else
        parentGOWithScript = null;
}
prevParentGOWithScript = parentGOWithScript;